#include <bits/stdc++.h>
using namespace std;
#define int long long

const int MASK[] = {0b1110111, 0b0010010, 0b1011101, 0b1011011, 0b0111010, 0b1101011, 0b1101111, 0b1010010, 0b1111111, 0b1111011};

vector<int> S;               // 有效的候选方式
vector<int> P[1LL << 7];     // 等价类
vector<int> Pmask[1LL << 7]; // 等价类对应的位掩码
int num[1LL << 7];           // 灯管数

// 等价类 v1 是否包含于等价类 v2
bool belong(vector<int> &v1, vector<int> &v2)
{
    for (auto x : v1)
    {
        bool in = 0;
        for (auto y : v2)
        {
            if ((x | y) == y)
            {
                in = 1;
                break;
            }
        }
        if (in == 0)
        {
            return 0;
        }
    }
    return 1;
}

void init()
{
    int up = 1LL << 7;
    for (int s = 0; s < up; s++)
    {
        num[s] = __builtin_popcount(s);

        for (int i = 0; i < 10; i++)
        {
            int mask1 = s & MASK[i];
            bool have = 0;
            for (int j = 0; j < Pmask[s].size(); j++)
            {
                int mask2 = Pmask[s][j];
                if (mask1 == mask2)
                {
                    have = 1;
                    P[s][j] |= (1LL << i);
                    break;
                }
            }
            if (have == 0)
            {
                P[s].push_back(1LL << i);
                Pmask[s].push_back(mask1);
            }
        }
    }
    for (int s = 0; s < up; s++)
    {
        bool ok = 1;
        for (auto s2 : S)
        {
            if (num[s2] <= num[s] && belong(P[s2], P[s]))
            {
                ok = 0;
                break;
            }
        }
        vector<int> vec;
        for (auto s2 : S)
        {
            if (num[s] <= num[s2] && belong(P[s], P[s2]))
            {
                vec.push_back(s2);
            }
        }
        for (auto s2 : vec)
        {
            S.erase(find(S.begin(), S.end(), s2));
        }
        if (ok == 1)
        {
            S.push_back(s);
        }
    }
}

bool vis[1LL << 24];

void solve()
{
    int n, m;
    cin >> n >> m;
    vector<int> a(n), b(n);
    vector<string> str(n);
    for (int i = 0; i < n; i++)
    {
        cin >> str[i];
        for (int j = 0; j < m; j++)
        {
            a[i] |= (MASK[str[i][j] - '0'] << (7 * j));
        }
    }

    int ans = 1e18 + 6;
    auto dfs = [&](auto dfs, int pos, int mask)
    {
        if (pos == m)
        {
            for (int i = 0; i < n; i++)
            {
                b[i] = a[i] & mask;
                if (vis[b[i]] == 1)
                {
                    for (int j = 0; j < i; j++)
                    {
                        vis[b[j]] = 0;
                    }
                    return;
                }
                vis[b[i]] = 1;
            }
            for (int i = 0; i < n; i++)
            {
                vis[b[i]] = 0;
            }

            ans = min(ans, (int)__builtin_popcount(mask));
            return;
        }
        for (auto s : S)
        {
            dfs(dfs, pos + 1, mask | (s << (7 * pos)));
        }
    };
    dfs(dfs, 0, 0);

    cout << ans << '\n';
}

signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    init();

    // cout << S.size() << '\n';

    int T = 1;
    cin >> T;
    while (T--)
    {
        solve();
    }

    return 0;
}
